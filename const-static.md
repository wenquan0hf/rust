# “常量”和“静态”

Rust 有用 const 关键字定义常量的方法：

    const N: i32 = 5;

不像 let 绑定那样，您必须标注常量的类型。

常量活在程序的整个生命周期。更具体地说，在 Rust 语言里面常量没有固定内存地址。这是因为他们会被有效的内联到每个使用地方。引用相同的常数并不一定保证引用同一个内存地址也是因为这个原因。

## 静态

Rust 在静态条目中提供一种“全局变量”。它们类似于常量，但静态条目不内联使用。这意味着每个值只对应一个实例， 并且在内存中只有一个固定的地址。

这里有一个例子：

    static N: i32 = 5;

不像 let 绑定那样，您必须标注一个静态的类型。

静态类型活在程序的整个生命周期，因此任何存储在常量中的引用都有“静态生命周期：

    static NAME: &'static str = "Steve";

## 可变性

你可以用 mut 关键字介绍可变性:

    static mut N: i32 = 5;

因为这是可变的，一个线程正在更新 N，而此时另一个正在读入它，这样会导致内存不安全。这样访问和改变一个静态 mut 是不安全的，所以必须在一个unsafe 的块里面完成：

    unsafe {
    N += 1;
    
    println!("N: {}", N);
    }

此外，任何存储在 static 的类型都必须是 Sync。

## 初始化

常量和静态常量都要求给他们一个值。并且他们可能只被赋予一个值，这个值是一个常数表达式。换句话说，在程序运行时，您不能使用函数调用的结果或任何其他类似的复杂操作。

## 我应该使用哪个构造?

几乎总是如此，如果你能在两者之间选择，那么就选择常量。人们几乎不怎么希望内存地址与你的常量关联到一起，并且允许对常量进行优化，就像常量的使用范围不仅在本程序块也在下游程序块一样。

常量可以被认为是在 C 语 言中用 # define 定义的:这里会有元数据开销，但没有运行开销。“在 C 语言中，我应该使用 # define 还是 static，“很大程度与这个问题是相同的，“在 Rus t语言中，我是应该使用 const 还是 static”。
